"""
A black-box test to test whether OBeLiX produces the expected descriptor values for a given set of xyz files generated by MACE.


"""

import os
import shutil

import numpy as np
import pandas as pd
import pytest

from obelix.descriptor_calculator import Descriptors
from obelix.run_workflow import Workflow


# path to the folder where the output of MACE (xyz files) and OBeLix (descriptors.csv) will be stored. This folder gets generated as a result of the MACE workflow being called.
path_to_workflow = os.path.abspath(os.path.join(os.path.dirname(__file__), "output"))

####################### Input for MACE ######################


# To do: specify input as a dictionary, then parameterize the fixture. Generate descriptor.csv for each input and keep in the expected_output/Dercriptors folder with the name descript_mace_config_1.csv, descript_mace_config_2.csv, etc. Check if mace_config is a suitable name for the mace input we define below. Since we do not compare the xyz files, we do not need to store them in the expected_output folder.
@pytest.fixture(scope="module")
def input_for_mace():
    """
    Prepare the input for MACE.

    Define a square planar geometry with a central Rhodium atom as the metal center. Square planar means that the metal center has 4 ligands in the same plane the other option is 'OH' for octahedral geometry
    """
    geom = "SP"
    central_atom = "[Rh+]"
    # SMILES and name of the ligand with two points of attachment to the metal center
    ligand_name = ["1-Naphthyl-DIPAMP"]
    ligand_smiles = ["c1ccc([P:1](CC[P:1](c2ccccc2)c2cccc3ccccc23)c2cccc3ccccc23)cc1"]
    # SMILES of the auxiliary ligands with one point of attachment to the metal center
    auxiliary_ligands = ["CC#[N:1]", "CC#[N:1]"]
    # in the SP geometry, the ligands are in the same plane, so we don't need a substrate for this example
    substrate = []
    # the input for MACE is a dictionary with the following keys
    # MACE input
    mace_input = {
        "bidentate_ligands": ligand_smiles,
        "auxiliary_ligands": auxiliary_ligands,
        "names_of_xyz": ligand_name,
        "central_atom": central_atom,
        "geom": geom,
        "substrate": substrate,
    }
    return mace_input


################ Input for Descriptor calculation ##############


@pytest.fixture(scope="module")
def xyz_files(input_for_mace):
    """
    Run the MACE workflow to generate the xyz files for the input defined in the fixture input_for_mace.

    Ouput of MACE is a set of xyz files and will be stored in the 'output/' folder in the current working directory.
    """
    workflow = Workflow(
        mace_input=input_for_mace,
        path_to_workflow=path_to_workflow,
        geom="BD",
    )
    # create the folder structure
    workflow.prepare_folder_structure()
    # create and write xyz files for the complexes defined by the input
    workflow.run_mace()
    xyz_files = os.path.join(path_to_workflow, "MACE")
    print("xyz files fixture called")
    return xyz_files


########################### Descriptor calculation ###########################


@pytest.fixture(scope="module")
def output_csv(xyz_files):
    """
    Calculate the descriptors for the xyz structures and write the descriptors to a csv file.
    """
    # path to MACE folder
    path_to_MACE_output = xyz_files
    # calculate the descriptors for the xyz structures
    descriptors = Descriptors(
        central_atom="Rh",
        path_to_workflow=path_to_MACE_output,
        output_type="xyz",
    )
    descriptors.calculate_morfeus_descriptors(
        geom_type="BD", solvent=None, printout=False, metal_adduct="pristine"
    )
    # write the descriptors to a csv file in the Descriptors folder
    descriptors.descriptor_df.to_csv(
        os.path.join(
            path_to_workflow,
            "Descriptors",
            "descriptors.csv",
        ),
        index=False,
    )
    output_csv = os.path.join(
        path_to_workflow,
        "Descriptors",
        "descriptors.csv",
    )
    print("Output csv fixture called")
    return output_csv


@pytest.fixture(scope="module")
def output_df(output_csv):
    """
    Convert the output csv file into a pandas dataframe for comparison with the expected csv file.
    """
    output_df = pd.read_csv(output_csv)
    print("Output df fixture called")
    return output_df


@pytest.fixture(scope="module")
def expected_csv():
    """
    This fixture provides the path to the expected csv file.

    The expected csv file contains the expected descriptor values for the xyz files generated by MACE for the input defined in the fixture input_for_mace.

    The expected csv file is pre-generated for a given set of xyz files and stored in the expected_output/Descriptors folder for comparison with the output csv file.
    """
    # path to the expected output csv file
    path_to_expected_csv = os.path.abspath(
        os.path.join(
            os.path.dirname(__file__),
            "expected_output",
            "Descriptors",
        )
    )
    expected_csv = os.path.join(path_to_expected_csv, "descriptors.csv")
    print("Expected csv fixture called")
    return expected_csv


@pytest.fixture(scope="module")
def expected_df(expected_csv):
    """
    Convert the expected csv file into a pandas dataframe for comparison with the output csv file.
    """
    expected_df = pd.read_csv(expected_csv)
    print("Expected df fixture called")
    return expected_df


########################### Testcases ###########################


def test_descriptor_values(output_df, expected_df):
    """
    The descriptor values in the output csv file must match the expected
    descriptor values for the same input.

    For ease of comparison, the descriptor values in the output and expected csv files are stored in pandas dataframes output_df and expected_df respectively.

    This test requests the output and expected dataframes via the fixtures output_df and expected_df.

    The dataframes are then compared to check if the descriptor values in the output csv file match the expected descriptor values for this input.
    The comparison is done by excluding the columns starting with name 'index' and 'element' from the dataframes and storing the descriptor values contained in the rows in numpy arrays for comparison.
    """
    # Exclude the columns starting with name 'index' and 'element' from the dataframes
    output_descriptor_values_df = output_df.loc[
        :, ~output_df.columns.str.contains("index|element|filename")
    ]
    expected_descriptor_values_df = expected_df.loc[
        :, ~expected_df.columns.str.contains("index|element|filename_tud")
    ]
    # store the descriptor values contained in the rows in numpy arrays for comparison
    output_descriptor_values = output_descriptor_values_df.to_numpy()
    expected_descriptor_values = expected_descriptor_values_df.to_numpy()
    assert np.allclose(
        output_descriptor_values, expected_descriptor_values
    ), "The descriptor values in the output csv file does not match the expected descriptor values for this input."


def test_index_values(output_df, expected_df):
    """
    The index values in the output csv file (dataframe) must match the expected
    index values for the same input.
    """
    output_index_values_df = output_df.loc[:, output_df.columns.str.contains("index")]
    expected_index_values_df = expected_df.loc[
        :, expected_df.columns.str.contains("index")
    ]
    assert output_index_values_df.equals(
        expected_index_values_df
    ), "The index values in the output csv file does not match the expected index values for this input."


def test_element_values(output_df, expected_df):
    """
    The element values in the output csv file (dataframe) must match the expected
    element values for the same input.
    """
    output_element_values_df = output_df.loc[
        :, output_df.columns.str.contains("element")
    ]
    expected_element_values_df = expected_df.loc[
        :, expected_df.columns.str.contains("element")
    ]
    assert output_element_values_df.equals(
        expected_element_values_df
    ), "The element values in the output csv file does not match the expected element values for this input."


def test_filename_values(output_df, expected_df):
    assert output_df["filename_tud"].equals(
        expected_df["filename_tud"]
    ), "The filename values in the output csv file does not match the expected filename values for this input."


#################### Clean up ####################


@pytest.fixture(scope="module", autouse=True)
def clean_up():
    """
    Delete the 'output/' folder generated as a result of the MACE workflow.
    """
    yield
    shutil.rmtree(path_to_workflow)
