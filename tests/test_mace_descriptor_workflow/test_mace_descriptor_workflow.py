"""
A black box test to test whether OBeLiX produces the expected descriptors csv file for the input xyz files generated by MACE.

Test steps:

1. Prepare the input for MACE
2. Run the MACE workflow to generate the xyz files
3. Calculate the descriptors for the xyz files
4. Write the descriptors to a csv file
5. Assert that the descriptor values in the output csv file match the expected descriptor values for this input
6. Assert that the index values in the output csv file match the expected index values for this input
7. Assert that the element values in the output csv file match the expected element values for this input
8. Assert that the filename values in the output csv file match the expected filename values for this input
9. Clean up the output generated by the test

"""

import os
import shutil

import numpy as np
import pandas as pd
import pytest

from obelix.descriptor_calculator import Descriptors
from obelix.run_workflow import Workflow


#################### Prepare the input for the test ####################

path_to_workflow = os.path.abspath(os.path.join(os.path.dirname(__file__), "output"))

## ---------- Input for MACE-------------##


# we define a square planar geometry with a central Rhodium atom as the metal center
# square planar means that the metal center has 4 ligands in the same plane
# the other option is 'OH' for octahedral geometry
@pytest.fixture
def input_for_mace():
    geom = "SP"
    central_atom = "[Rh+]"

    # SMILES and name of the ligand with two points of attachment to the metal center
    ligand_name = ["1-Naphthyl-DIPAMP"]
    ligand_smiles = ["c1ccc([P:1](CC[P:1](c2ccccc2)c2cccc3ccccc23)c2cccc3ccccc23)cc1"]

    # SMILES of the auxiliary ligands with one point of attachment to the metal center
    auxiliary_ligands = ["CC#[N:1]", "CC#[N:1]"]
    # in the SP geometry, the ligands are in the same plane, so we don't need a substrate for this example
    substrate = []

    # the input for MACE is a dictionary with the following keys
    # MACE input
    mace_input = {
        "bidentate_ligands": ligand_smiles,
        "auxiliary_ligands": auxiliary_ligands,
        "names_of_xyz": ligand_name,
        "central_atom": central_atom,
        "geom": geom,
        "substrate": substrate,
    }
    print("Input for MACE fixture called")
    return mace_input


## ---------- Input for Descriptor calculation-------------##
@pytest.fixture
def xyz_files(input_for_mace):

    # Ouput of MACE is a set of xyz files and will be stored in the output_produced/ folder in the current working directory. Use absolute path.
    workflow = Workflow(
        mace_input=input_for_mace,
        path_to_workflow=path_to_workflow,
        geom="BD",
    )

    # create the folder structure
    workflow.prepare_folder_structure()
    # create and write xyz files for the complexes defined by the input
    workflow.run_mace()

    xyz_files = os.path.join(path_to_workflow, "MACE")
    print("xyz files fixture called")
    return xyz_files


#################### Descriptor calculation ####################
@pytest.fixture
def output_csv(xyz_files):

    # path to MACE folder
    path_to_MACE_output = xyz_files

    # calculate the descriptors for the xyz structures
    descriptors = Descriptors(
        central_atom="Rh",
        path_to_workflow=path_to_MACE_output,
        output_type="xyz",
    )

    descriptors.calculate_morfeus_descriptors(
        geom_type="BD", solvent=None, printout=False, metal_adduct="pristine"
    )

    # write the descriptors to a csv file in the Descriptors folder
    descriptors.descriptor_df.to_csv(
        os.path.join(
            path_to_workflow,
            "Descriptors",
            "descriptors.csv",
        ),
        index=False,
    )

    output_csv = os.path.join(
        path_to_workflow,
        "Descriptors",
        "descriptors.csv",
    )
    print("Output csv fixture called")
    return output_csv


@pytest.fixture
def output_df(output_csv):
    output_df = pd.read_csv(output_csv)
    print("Output df fixture called")
    return output_df


@pytest.fixture
def expected_csv():
    # path to the expected output csv file
    path_to_expected_csv = os.path.abspath(
        os.path.join(
            os.path.dirname(__file__),
            "expected_output",
            "Descriptors",
        )
    )
    expected_csv = os.path.join(path_to_expected_csv, "descriptors.csv")
    print("Expected csv fixture called")
    return expected_csv


@pytest.fixture
def expected_df(expected_csv):
    expected_df = pd.read_csv(expected_csv)
    print("Expected df fixture called")
    return expected_df


########################### Testcases ###########################


def test_descriptor_values(output_df, expected_df):
    """
    The descriptor values in the output csv file must match the expected
    descriptor values for the same input.
    """

    # Exclude the columns starting with name 'index' and 'element' from the dataframes
    output_descriptor_values_df = output_df.loc[
        :, ~output_df.columns.str.contains("index|element|filename")
    ]
    expected_descriptor_values_df = expected_df.loc[
        :, ~expected_df.columns.str.contains("index|element|filename_tud")
    ]

    # store the descriptor values contained in the rows in numpy arrays for comparison
    output_descriptor_values = output_descriptor_values_df.to_numpy()
    expected_descriptor_values = expected_descriptor_values_df.to_numpy()

    assert np.allclose(
        output_descriptor_values, expected_descriptor_values
    ), "The descriptor values in the output csv file does not match the expected descriptor values for this input."


def test_index_values(output_df, expected_df):
    """
    The index values in the output csv file must match the expected
    index values for the same input.
    """

    output_index_values_df = output_df.loc[:, output_df.columns.str.contains("index")]

    expected_index_values_df = expected_df.loc[
        :, expected_df.columns.str.contains("index")
    ]

    assert output_index_values_df.equals(
        expected_index_values_df
    ), "The index values in the output csv file does not match the expected index values for this input."


# def test_index_values(prep_output_for_comparison):
#     output_index_values_df = prep_output_for_comparison["output_df"].loc[
#         :, prep_output_for_comparison["output_df"].columns.str.contains("index")
#     ]

#     expected_index_values_df = prep_output_for_comparison["expected_df"].loc[
#         :, prep_output_for_comparison["expected_df"].columns.str.contains("index")
#     ]

#     assert output_index_values_df.equals(
#         expected_index_values_df
#     ), "The index values in the output csv file does not match the expected index values for this input."


def test_element_values(output_df, expected_df):
    """
    The element values in the output csv file must match the expected
    element values for the same input.
    """

    output_element_values_df = output_df.loc[
        :, output_df.columns.str.contains("element")
    ]

    expected_element_values_df = expected_df.loc[
        :, expected_df.columns.str.contains("element")
    ]

    assert output_element_values_df.equals(
        expected_element_values_df
    ), "The element values in the output csv file does not match the expected element values for this input."


# def test_element_values(prep_output_for_comparison):
#     output_element_values_df = prep_output_for_comparison["output_df"].loc[
#         :, prep_output_for_comparison["output_df"].columns.str.contains("element")
#     ]

#     expected_element_values_df = prep_output_for_comparison["expected_df"].loc[
#         :, prep_output_for_comparison["expected_df"].columns.str.contains("element")
#     ]

#     assert output_element_values_df.equals(
#         expected_element_values_df
#     ), "The element values in the output csv file does not match the expected element values for this input."


def test_filename_values(output_df, expected_df):
    assert output_df["filename_tud"].equals(
        expected_df["filename_tud"]
    ), "The filename values in the output csv file does not match the expected filename values for this input."


#################### Clean up ####################


# Delete the outputs generated by the test
# use yield to run the cleanup code after all the tests have run
@pytest.fixture(autouse=True)
def cleanup():
    yield
    # delete the output folder
    shutil.rmtree(path_to_workflow)
    print("Clean up done")
