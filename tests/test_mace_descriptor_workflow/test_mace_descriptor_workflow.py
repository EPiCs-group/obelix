"""
This tests compares the descriptor values generated by OBeLiX for a given set of xyz files with the expected descriptor values for the same set of xyz files. The expected descriptor values are stored in a csv file in the expected_output folder.

When this test is run, the following sequence of events occur:

1. The calculate_descriptors fixture is run to generate the input for MACE, run the MACE workflow, and calculate the descriptors for the xyz files generated by MACE.
2. The testcases are run with the data provided by the calculate_descriptors fixture.
3. The output folder generated as a result of the MACE workflow is deleted after the test is executed.


*************** Running the test ***************

Run this test only:
`pytest -v tests/test_mace_descriptor_workflow/test_mace_descriptor_workflow.py`

Run all the tests in the repository:
`pytest -v` in the terminal from the root directory of the repository.

"""

import os
import shutil
from typing import Any

import numpy as np
import pandas as pd
import pytest

from obelix.descriptor_calculator import Descriptors
from obelix.run_workflow import Workflow


@pytest.fixture(scope="module")  # setting scope='module' runs this fixture
# only once for all the testcases defined in # this module. This is because
# the fixtures are computationally expensive and # the data generated by the  # fixtures are not modified by the testcases.
def calculate_descriptors():

    ### construct input for MACE ###

    geom = "SP"
    central_atom = "[Rh+]"
    # SMILES and name of the ligand with two points of attachment to the metal center
    ligand_name = ["1-Naphthyl-DIPAMP"]
    ligand_smiles = ["c1ccc([P:1](CC[P:1](c2ccccc2)c2cccc3ccccc23)c2cccc3ccccc23)cc1"]
    # SMILES of the auxiliary ligands with one point of attachment to the metal center
    auxiliary_ligands = ["CC#[N:1]", "CC#[N:1]"]
    # in the SP geometry, the ligands are in the same plane, so we don't need a substrate for this example
    substrate = []
    # the input for MACE is a dictionary with the following keys
    mace_input = {
        "bidentate_ligands": ligand_smiles,
        "auxiliary_ligands": auxiliary_ligands,
        "names_of_xyz": ligand_name,
        "central_atom": central_atom,
        "geom": geom,
        "substrate": substrate,
    }

    ### Run the MACE workflow to generate the xyz files ###

    # 'output/' holds the outputs generated by the MACE workflow and the
    # descriptor calculator triggered as part of the test. The output includes
    # the MACE folder containing the xyz files generated by MACE and the
    # Descriptors folder containing the descriptors.csv file generated by the
    # descriptor calculator.
    path_workflow_output = os.path.abspath(
        os.path.join(os.path.dirname(__file__), "output")
    )

    workflow = Workflow(
        mace_input=mace_input,
        path_to_workflow=path_workflow_output,
        geom="BD",
    )

    # create the folder structure
    workflow.prepare_folder_structure()

    # create and write xyz files for the complexes defined by the input
    workflow.run_mace()
    xyz_files = os.path.join(path_workflow_output, "MACE")

    # path to MACE folder containing the xyz files
    path_to_mace_output = xyz_files

    # calculate the descriptors for the xyz structures
    descriptors = Descriptors(
        central_atom="Rh",
        path_to_workflow=path_to_mace_output,
        output_type="xyz",
    )
    descriptors.calculate_morfeus_descriptors(
        geom_type="BD", solvent=None, printout=False, metal_adduct="pristine"
    )

    # write the descriptors to a csv file in the Descriptors folder
    descriptors.descriptor_df.to_csv(
        os.path.join(
            path_workflow_output,
            "Descriptors",
            "descriptors.csv",
        ),
        index=False,
    )

    yield

    # Clean up the output folder after the test
    shutil.rmtree(path_workflow_output)


class TestMaceDescriptorWorkflow:
    def test_descriptor_values(self, calculate_descriptors):
        self.compare_csv_contents(
            exclude_columns=["index", "element", "filename_tud"],
        )

    def test_index_values(self, calculate_descriptors):
        self.compare_csv_contents(include_columns=["index"])

    def test_element_values(self, calculate_descriptors):
        self.compare_csv_contents(include_columns=["element"])

    def test_filename_values(self, calculate_descriptors):
        self.compare_csv_contents(include_columns=["filename_tud"])

    def compare_csv_contents(
        self,
        include_columns=None,
        exclude_columns=None,
    ):
        """
        This is a helper function to compare the contents of the output csv
        file with the expected csv file. Extracting out this function helps to
        avoid code duplication in the test methods.
        """
        path_expected_csv = os.path.join(
            os.path.abspath(os.path.dirname(__file__)),
            "expected_output",
            "descriptors.csv",
        )
        output_csv = os.path.join(
            os.path.abspath(os.path.dirname(__file__)),
            "output",
            "Descriptors",
            "descriptors.csv",
        )

        expected_df = pd.read_csv(path_expected_csv)
        output_df = pd.read_csv(output_csv)

        # Filter the columns based on the include_columns or exclude_columns
        # parameter and compare the values. If include_columns is provided,
        # use DataFrame.equals for comparison. If exclude_columns is provided
        # use np.allclose for comparison. This is because DataFrame.equals is
        # used for non-numeric data comparison (index, filenme and element
        # values), while np.allclose is used for numeric data comparison (descriptor values).
        if include_columns:
            filtered_columns = expected_df.columns[
                expected_df.columns.str.contains("|".join(include_columns))
            ]
            expected_df = expected_df.loc[:, filtered_columns]
            output_df = output_df.loc[:, filtered_columns]
            # Use DataFrame.equals for non-numeric data comparison
            assert expected_df.equals(
                output_df
            ), f"The {include_columns} values in the output csv file do not match"
        elif exclude_columns:
            # For numeric data, use np.allclose after excluding non-numeric columns
            filtered_columns = expected_df.columns[
                ~expected_df.columns.str.contains("|".join(exclude_columns))
            ]
            expected_df = expected_df.loc[:, filtered_columns]
            output_df = output_df.loc[:, filtered_columns]

            output_descriptor_values = output_df.to_numpy()

            # Convert True/False values to 1/0
            output_descriptor_values = np.where(
                output_descriptor_values is True, 1, output_descriptor_values
            )
            output_descriptor_values = np.where(
                output_descriptor_values is False, 0, output_descriptor_values
            )

            # Convert each element in the array to a numeric type (float by
            # default). If an element cannot be converted (e.g., a string that
            # doesn't represent a number), it is replaced with NaN (Not a
            # Number), as a result of the errors='coerce' parameter. This step
            # ensures that the entire array is numeric, which is a
            # prerequisite for using np.allclose.
            output_descriptor_values = pd.to_numeric(
                output_descriptor_values.flatten(), errors="coerce"
            ).reshape(output_descriptor_values.shape)

            expected_descriptor_values = expected_df.to_numpy()

            expected_descriptor_values = np.where(
                expected_descriptor_values is True, 1, expected_descriptor_values
            )
            expected_descriptor_values = np.where(
                expected_descriptor_values is False, 0, expected_descriptor_values
            )

            expected_descriptor_values = pd.to_numeric(
                expected_descriptor_values.flatten(), errors="coerce"
            ).reshape(expected_descriptor_values.shape)

            assert np.allclose(
                output_descriptor_values, expected_descriptor_values, equal_nan=True
            ), (
                f"The descriptor values in the output csv file do not match"
                f"the expected descriptor values for this input."
            )
        else:
            raise ValueError(
                "Either include_columns or exclude_columns must be provided."
            )
