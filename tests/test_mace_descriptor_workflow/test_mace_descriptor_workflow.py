"""
A black box test to tets whether Obelix produces the expected output for a given input.
This test checks if Obelix produces the same descriptors csv file for the same input xyz files. The input xyz files are generated by MACE.
In this test, stert from the input ligand/substrate, generate the xyz files with MACE, calculate the descriptors, and compare the output csv file with the expected csv file.
Use pytest to run the test.

"""

import os

from obelix.descriptor_calculator import Descriptors
from obelix.run_workflow import Workflow


# Use pytest fixtures to define the input for the testcases. Break the implemenattion of this test into
# 1. Arrange: Define the input for the testcases
# 2. Act: Run the workflow
# 3. Assert: Compare the produced csv file with the expected csv file
# 4. Clean up: Remove the folder structure created by the workflow


## ---------- Input for MACE-------------##

# we define a square planar geometry with a central Rhodium atom as the metal center
# square planar means that the metal center has 4 ligands in the same plane
# the other option is 'OH' for octahedral geometry
geom = "SP"
central_atom = "[Rh+]"

# SMILES and name of the ligand with two points of attachment to the metal center
ligand_name = ["1-Naphthyl-DIPAMP"]
ligand_smiles = ["c1ccc([P:1](CC[P:1](c2ccccc2)c2cccc3ccccc23)c2cccc3ccccc23)cc1"]

# SMILES of the auxiliary ligands with one point of attachment to the metal center
auxiliary_ligands = ["CC#[N:1]", "CC#[N:1]"]
# in the SP geometry, the ligands are in the same plane, so we don't need a substrate for this example
substrate = []

# the input for MACE is a dictionary with the following keys
# MACE input
mace_input = {
    "bidentate_ligands": ligand_smiles,
    "auxiliary_ligands": auxiliary_ligands,
    "names_of_xyz": ligand_name,
    "central_atom": central_atom,
    "geom": geom,
    "substrate": substrate,
}


##---------- Workflow -------------##

path_to_workflow = os.path.abspath(
    os.path.join(os.path.dirname(__file__), "output_produced")
)

# Ouput of MACE is a set of xyz files and will be stored in the output_produced/ folder in the current working directory. Use absolute path.
workflow = Workflow(
    mace_input=mace_input,
    path_to_workflow=path_to_workflow,
    geom="BD",
)


# create the folder structure
workflow.prepare_folder_structure()
# create and write xyz files for the complexes defined by the input
workflow.run_mace()


##---------- Descriptor calculation -------------##

# path to MACE folder
path_to_MACE_output = os.path.join(path_to_workflow, "MACE")
print("path_to_workflow line 62 is: ", path_to_MACE_output)

# xyz files are in MACE folde. use absolute path to point to the MACE folder.
descriptors = Descriptors(
    central_atom="Rh",
    path_to_workflow=path_to_MACE_output,
    output_type="xyz",
)
# calculate the descriptors for the xyz structures
descriptors.calculate_morfeus_descriptors(
    geom_type="BD", solvent=None, printout=False, metal_adduct="pristine"
)

# write the descriptors to a csv file in the Descriptors folder
descriptors.descriptor_df.to_csv(
    os.path.join(path_to_workflow, "Descriptors", "descriptors.csv"), index=False
)


##---------- Assert csv file produced with the Expected output csv file-------------##

# path to the expected output csv file
path_to_expected_output = os.path.abspath(
    os.path.join(
        os.path.dirname(__file__),
        "output_expected",
        "Descriptors",
    )
)
# read the expected output csv file
expected_output = os.path.join(path_to_expected_output, "descriptors.csv")


# read the produced output csv file
produced_output = os.path.join(path_to_workflow, "Descriptors", "descriptors.csv")

# compare the expected and produced csv files. There is no read_csv method in the Descriptors class. So, we use pandas to read the csv files.
import pandas as pd

# assert logic:
# export the csv file into a pandas dataframe and exclude the columns starting with name 'index' and 'element'

produced_df = pd.read_csv(produced_output)
print("produced_df before removing columns is: ", produced_df)
produced_df = produced_df.loc[
    :, ~produced_df.columns.str.contains("^index|^element|^filename")
]

print("produced_df after removing columns is : ", produced_df)

expected_df = pd.read_csv(expected_output)
print("expected_df before removing columns is: ", expected_df)

expected_df = expected_df.loc[
    :, ~expected_df.columns.str.contains("^index|^element|^filename")
]
print("expected_df after removing columns is : ", expected_df)

# store the rows in numpy arrays and compare the two arrays using numpy allclose method

import numpy as np

# extract rows from the dataframes and store them in numpy arrays
produced_array = produced_df.to_numpy()

print("produced_array is: ", produced_array)

expected_array = expected_df.to_numpy()

assert np.allclose(
    produced_array,
    expected_array,
), "The produced csv file is different from the expected csv file."


# clean up
import shutil

shutil.rmtree(path_to_workflow)
